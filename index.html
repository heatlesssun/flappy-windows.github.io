<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>Flappy Windows: Rescue the Tuxes</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    body{
      background:linear-gradient(135deg,#1a1a2e 0%,#16213e 50%,#0f3460 100%);
      min-height:100vh;display:flex;justify-content:center;align-items:center;
      font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;overflow:hidden;touch-action:manipulation
    }
    #gameWrap{position:relative;width:100%;max-width:450px;aspect-ratio:9/16;max-height:100vh}
    canvas{width:100%;height:100%;display:block;border-radius:8px;box-shadow:0 0 30px rgba(0,170,255,.3)}
    #startScreen,#gameOver{
      position:absolute;top:0;left:0;width:100%;height:100%;
      display:flex;flex-direction:column;justify-content:center;align-items:center;
      background:rgba(0,0,0,.85);border-radius:8px;padding:20px;text-align:center
    }
    #gameOver{display:none}
    h1{color:#fc0;font-size:clamp(1.5rem,5vw,2.5rem);margin-bottom:10px;text-shadow:2px 2px 4px rgba(0,0,0,.5)}
    .sub{color:#0af;font-size:clamp(.9rem,3vw,1.2rem);margin-bottom:30px;font-style:italic}
    .ins{color:#ccc;font-size:clamp(.8rem,2.5vw,1rem);margin-bottom:20px;line-height:1.6}
    .ins span{color:#fc0;font-weight:700}
    .btn{
      background:linear-gradient(135deg,#fc0 0%,#f90 100%);
      color:#1a1a2e;border:none;padding:15px 40px;font-size:clamp(1rem,3vw,1.3rem);
      font-weight:700;border-radius:30px;cursor:pointer;transition:transform .2s,box-shadow .2s;margin:10px
    }
    .btn:hover,.btn:active{transform:scale(1.05);box-shadow:0 5px 20px rgba(255,204,0,.4)}
    #finalScore{color:#fc0;font-size:clamp(2rem,6vw,3rem);margin:15px 0}
    #crashMsg{
      color:#ff6b6b;font-size:clamp(.85rem,2.5vw,1.1rem);
      margin:20px;padding:15px;background:rgba(255,107,107,.1);
      border-radius:10px;border:1px solid rgba(255,107,107,.3);max-width:90%;line-height:1.5
    }
    .small{color:#888;font-size:clamp(.8rem,2vw,1rem)}
    #score{
      position:absolute;top:20px;left:50%;transform:translateX(-50%);
      color:#fc0;font-size:clamp(1.5rem,5vw,2rem);font-weight:700;
      text-shadow:2px 2px 4px rgba(0,0,0,.8);z-index:10;pointer-events:none
    }
    .credit{position:absolute;bottom:10px;color:#666;font-size:.7rem}
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="c"></canvas>
    <div id="score">0</div>

    <div id="startScreen">
      <h1>ðŸªŸ Flappy Windows</h1>
      <div class="sub">Rescue your time</div>
      <div class="ins">
        <span>TAP</span> to flap<br/>
        <span>COLLECT</span> Windows for the win!<br/>
        <span>AVOID</span> All that Wine "features"<br/><br/>
      </div>
      <button class="btn" id="startBtn">START</button>
      <div class="credit">A satirical tribute to bloatware everywhere</div>
    </div>

    <div id="gameOver">
      <h1>ðŸ’€ SYSTEM CRASH</h1>
      <div class="small">Tuxes Rescued:</div>
      <div id="finalScore">0</div>
      <div id="crashMsg"></div>
      <button class="btn" id="retryBtn">TRY AGAIN</button>
      <button class="btn" id="menuBtn" style="background:linear-gradient(135deg,#666 0%,#444 100%);color:#fff">MENU</button>
    </div>
  </div>

<script>
(() => {
  // ---------- Content ----------
const DEATH_MESSAGES = [
  "Kernel panic. Not syncing. Your penguin has left the chat.",
  "Copilot suggests: 'Have you tried recompiling the kernel?'",
  "Recall captured 47 screenshots, but X11 dropped half of them.",
  "Telemetry collected: nothing. Absolutely nothing. Also you still crashed.",
  "A reboot is required. The init system is arguing about how.",
  "Your default editor was vim. You couldn't figure out how to quit.",
  "Installing updates: pacman, apt, dnf, snap, flatpakâ€¦ choose wisely.",
  "This system requires sudo. You were not in the sudoers file."
];

const OBSTACLES = [
  { name: "Systemd",   color: "#9b59b6", icon: "âš™ï¸", tag: "PID 1" },
  { name: "Wayland",   color: "#e74c3c", icon: "ðŸ–¥ï¸", tag: "Itâ€™s Different" },
  { name: "Drivers",   color: "#3498db", icon: "ðŸ§©", tag: "Out of Tree" },
  { name: "Permissions", color: "#e67e22", icon: "ðŸ”’", tag: "Access Denied" },
  { name: "Kernel",    color: "#2ecc71", icon: "ðŸ§", tag: "Panic!" },
  { name: "Package Manager", color: "#00a1f1", icon: "ðŸ“¦", tag: "Dependency Hell" },
  { name: "GRUB",      color: "#f39c12", icon: "ðŸ“œ", tag: "Which OS?" },
  { name: "Arch Wiki", color: "#ff6b9d", icon: "ðŸ“–", tag: "RTFM" }
];

  const CFG = {
    gravity: 0.4,
    flapVel: -8,
    scroll: 3,
    gap: 180,
    obstacleEvery: 150,
    tuxEvery: 100, // collectible spawn rate
    playerSize: 40
  };

  // ---------- Tiny synth ----------
  class Sfx {
    constructor(){ this.ctx=null; this.ready=false; }
    init(){
      if(this.ready) return;
      try { this.ctx = new (window.AudioContext||window.webkitAudioContext)(); this.ready=true; } catch {}
    }
    tone(freq, dur, type="square", vol=0.3){
      if(!this.ctx) return;
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.connect(g); g.connect(this.ctx.destination);
      o.frequency.value = freq; o.type = type;
      g.gain.setValueAtTime(vol, this.ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
      o.start(); o.stop(this.ctx.currentTime + dur);
    }
    flap(){ this.tone(420,0.10,"sine",0.22); setTimeout(()=>this.tone(520,0.10,"sine",0.16),50); }
    eat(){ this.tone(600,0.08,"square",0.20); this.tone(850,0.08,"square",0.20); setTimeout(()=>this.tone(1050,0.12,"square",0.24),80); }
    crash(){ this.tone(200,0.30,"sawtooth",0.40); setTimeout(()=>this.tone(150,0.30,"sawtooth",0.30),100); setTimeout(()=>this.tone(100,0.40,"sawtooth",0.20),200); }
  }

  // ---------- Game ----------
  class Game {
    constructor(){
      this.cv = document.getElementById("c");
      this.cx = this.cv.getContext("2d");

      this.sfx = new Sfx();

      this.startScreen = document.getElementById("startScreen");
      this.gameOver = document.getElementById("gameOver");
      this.scoreEl = document.getElementById("score");
      this.finalScoreEl = document.getElementById("finalScore");
      this.crashMsgEl = document.getElementById("crashMsg");

      this.wrap = document.getElementById("gameWrap");
      window.addEventListener("resize", () => this.resize());
      this.bind();
      this.reset();
      this.resize();
    }

    bind(){
      const flapHandler = (e) => {
        e.preventDefault();
        if(this.running && !this.ended) this.flap();
      };

      this.cv.addEventListener("touchstart", flapHandler, { passive:false });
      this.cv.addEventListener("mousedown", flapHandler);
      document.addEventListener("keydown", (e) => { if(e.code==="Space") flapHandler(e); });

      document.getElementById("startBtn").addEventListener("click", () => this.start());
      document.getElementById("retryBtn").addEventListener("click", () => this.start());
      document.getElementById("menuBtn").addEventListener("click", () => this.menu());

      document.addEventListener("contextmenu", e => e.preventDefault());
      document.addEventListener("keydown", e => {
        if ((e.ctrlKey||e.metaKey) && ["u","s","i","j"].includes(e.key.toLowerCase())) e.preventDefault();
        if (e.key === "F12") e.preventDefault();
      });
    }

    resize(){
      const r = this.wrap.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      // IMPORTANT: reset transform so resizes don't stack scaling
      this.cx.setTransform(1,0,0,1,0,0);

      this.cv.width = Math.floor(r.width * dpr);
      this.cv.height = Math.floor(r.height * dpr);

      this.cx.setTransform(dpr,0,0,dpr,0,0);

      this.w = r.width;
      this.h = r.height;
    }

    reset(){
      this.player = { x: this.w * 0.2, y: this.h/2, v: 0, rot: 0 };
      this.obstacles = [];
      this.tuxes = [];      // collectibles (now tux)
      this.particles = [];
      this.score = 0;
      this.frame = 0;
      this.running = false;
      this.ended = false;
      this.lastObstacleIndex = null;
    }

    start(){
      this.sfx.init();
      this.reset();
      this.startScreen.style.display = "none";
      this.gameOver.style.display = "none";
      this.running = true;
      this.loop();
    }

    menu(){
      this.gameOver.style.display = "none";
      this.startScreen.style.display = "flex";
      this.reset();
    }

    flap(){
      this.player.v = CFG.flapVel;
      this.sfx.flap();
      for(let i=0;i<3;i++){
        this.particles.push({
          x: this.player.x - 10,
          y: this.player.y,
          vx: -Math.random()*2 - 1,
          vy: (Math.random()-0.5)*2,
          life: 20,
          color: "#fc0"
        });
      }
    }

    spawnObstacle(){
      let idx;
      do { idx = Math.floor(Math.random() * OBSTACLES.length); }
      while (idx === this.lastObstacleIndex && OBSTACLES.length > 1);

      this.lastObstacleIndex = idx;
      const type = OBSTACLES[idx];
      const gapY = Math.random() * (this.h - CFG.gap - 200) + 100;

      this.obstacles.push({ x: this.w, gapY, w: 60, type });
    }

    spawnTux(){
      this.tuxes.push({
        x: this.w,
        y: Math.random() * (this.h - 100) + 50,
        size: 30,
        rot: 0,
        collected: false
      });
    }

    rectHit(a,b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    circleRectHit(cx, cy, r, rt){
      const clx = Math.max(rt.x, Math.min(cx, rt.x + rt.w));
      const cly = Math.max(rt.y, Math.min(cy, rt.y + rt.h));
      const dx = cx - clx, dy = cy - cly;
      return (dx*dx + dy*dy) < (r*r);
    }

    checkCollisions(){
      const hitbox = {
        x: this.player.x - CFG.playerSize/2 + 5,
        y: this.player.y - CFG.playerSize/2 + 5,
        w: CFG.playerSize - 10,
        h: CFG.playerSize - 10
      };

      // bounds
      if (this.player.y < 0 || this.player.y > this.h - CFG.playerSize/2) return this.end();

      // pipes
      for (const o of this.obstacles){
        // top pipe
        if (this.rectHit(hitbox, { x:o.x, y:0, w:o.w, h:o.gapY })) return this.end();
        // bottom pipe
        if (this.rectHit(hitbox, { x:o.x, y:o.gapY + CFG.gap, w:o.w, h:this.h - o.gapY - CFG.gap })) return this.end();
      }

      // collectibles (tux)
      for (const t of this.tuxes){
        if (t.collected) continue;
        if (this.circleRectHit(t.x, t.y, t.size/2, hitbox)){
          t.collected = true;
          this.score += 10;
          this.sfx.eat();

          // confetti-ish particles
          const cols = ["#00a1f1","#7fba00","#f25022","#ffb900"];
          for(let i=0;i<10;i++){
            this.particles.push({
              x: t.x, y: t.y,
              vx: (Math.random()-0.5)*6,
              vy: (Math.random()-0.5)*6,
              life: 30,
              color: cols[Math.floor(Math.random()*cols.length)]
            });
          }
        }
      }
    }

    end(){
      if (this.ended) return;
      this.ended = true;
      this.running = false;
      this.sfx.crash();

      this.finalScoreEl.textContent = this.score;
      this.crashMsgEl.textContent = DEATH_MESSAGES[Math.floor(Math.random() * DEATH_MESSAGES.length)];

      setTimeout(() => this.gameOver.style.display = "flex", 500);
    }

    update(){
      this.frame++;

      // physics
      this.player.v += CFG.gravity;
      this.player.y += this.player.v;
      this.player.rot = Math.min(Math.max(this.player.v * 3, -30), 45);

      // spawns
      if (this.frame % CFG.obstacleEvery === 0) this.spawnObstacle();
      if (this.frame % CFG.tuxEvery === 0) this.spawnTux();

      // move
      for (const o of this.obstacles) o.x -= CFG.scroll;
      this.obstacles = this.obstacles.filter(o => o.x > -o.w);

      for (const t of this.tuxes){
        t.x -= CFG.scroll * 0.8;
        t.rot += 2;
      }
      this.tuxes = this.tuxes.filter(t => t.x > -t.size && !t.collected);

      for (const p of this.particles){
        p.x += p.vx; p.y += p.vy; p.life--;
      }
      this.particles = this.particles.filter(p => p.life > 0);

      this.checkCollisions();
      this.scoreEl.textContent = this.score;
    }

    drawBackground(){
      this.cx.fillStyle = "#e00a00";
      this.cx.fillRect(0,0,this.w,this.h);

      this.cx.strokeStyle = "rgba(255,255,255,0.25)";
      this.cx.lineWidth = 1;
      for(let x=0;x<this.w;x+=30){ this.cx.beginPath(); this.cx.moveTo(x,0); this.cx.lineTo(x,this.h); this.cx.stroke(); }
      for(let y=0;y<this.h;y+=30){ this.cx.beginPath(); this.cx.moveTo(0,y); this.cx.lineTo(this.w,y); this.cx.stroke(); }
    }

    drawParticles(){
      for (const p of this.particles){
        this.cx.fillStyle = p.color;
        this.cx.globalAlpha = p.life / 30;
        this.cx.beginPath();
        this.cx.arc(p.x, p.y, 3, 0, Math.PI*2);
        this.cx.fill();
      }
      this.cx.globalAlpha = 1;
    }

    // ---- SWAP #1: Player is now Windows logo ----
    drawWindowsPlayer(){
      const {x,y,rot} = this.player;
      const s = CFG.playerSize;

      this.cx.save();
      this.cx.translate(x,y);
      this.cx.rotate(rot * Math.PI / 180);

      // 4-squares Windows logo
      const z = s * 0.4;
      const gap = 2;
      const cs = ["#f25022","#7fba00","#00a4ef","#ffb900"];
      const ps = [
        [-z-gap/2, -z-gap/2],
        [ gap/2,    -z-gap/2],
        [-z-gap/2,  gap/2],
        [ gap/2,     gap/2]
      ];

      for(let i=0;i<4;i++){
        this.cx.fillStyle = cs[i];
        this.cx.fillRect(ps[i][0], ps[i][1], z, z);
      }

      // glow
      this.cx.shadowColor = "#00a4ef";
      this.cx.shadowBlur = 10;

      this.cx.restore();
      this.cx.shadowBlur = 0;
    }

    // ---- SWAP #2: Collectible is now Tux drawing ----
    drawTuxCollectible(x,y,size,rotDeg){
      const s = size;
      this.cx.save();
      this.cx.translate(x,y);
      this.cx.rotate(rotDeg * Math.PI / 180);

      // body (mini tux head/body)
      this.cx.fillStyle = "#1a1a1a";
      this.cx.beginPath();
      this.cx.ellipse(0,0,s*0.42,s*0.52,0,0,Math.PI*2);
      this.cx.fill();

      // belly/face
      this.cx.fillStyle = "#f5f5f5";
      this.cx.beginPath();
      this.cx.ellipse(0,s*0.05,s*0.30,s*0.40,0,0,Math.PI*2);
      this.cx.fill();

      // eyes
      this.cx.fillStyle = "white";
      this.cx.beginPath();
      this.cx.ellipse(-s*0.12,-s*0.25,s*0.12,s*0.14,0,0,Math.PI*2);
      this.cx.ellipse( s*0.12,-s*0.25,s*0.12,s*0.14,0,0,Math.PI*2);
      this.cx.fill();

      this.cx.fillStyle = "#1a1a1a";
      this.cx.beginPath();
      this.cx.arc(-s*0.08,-s*0.25,s*0.06,0,Math.PI*2);
      this.cx.arc( s*0.16,-s*0.25,s*0.06,0,Math.PI*2);
      this.cx.fill();

      // beak
      this.cx.fillStyle = "#f4a423";
      this.cx.beginPath();
      this.cx.moveTo(0,-s*0.12);
      this.cx.lineTo(s*0.15,-s*0.05);
      this.cx.lineTo(0, s*0.05);
      this.cx.lineTo(-s*0.15,-s*0.05);
      this.cx.closePath();
      this.cx.fill();

      this.cx.restore();
    }

    drawObstacle(o){
      const {x, gapY, w, type} = o;
      this.drawPipe(x, 0, w, gapY, type, false);
      this.drawPipe(x, gapY + CFG.gap, w, this.h - gapY - CFG.gap, type, true);
    }

    lighten(hex, pct){
      const n = parseInt(hex.replace("#",""),16);
      const a = Math.round(2.55 * pct);
      const R = (n>>16) + a;
      const G = ((n>>8)&0xFF) + a;
      const B = (n&0xFF) + a;
      const clamp = v => (v<0?0:(v>255?255:v));
      return "#" + (0x1000000 + clamp(R)*0x10000 + clamp(G)*0x100 + clamp(B)).toString(16).slice(1);
    }

    drawPipe(x,y,w,h,type,isBottom){
      const gr = this.cx.createLinearGradient(x,y,x+w,y);
      gr.addColorStop(0, type.color);
      gr.addColorStop(0.5, this.lighten(type.color, 30));
      gr.addColorStop(1, type.color);

      this.cx.fillStyle = gr;
      this.cx.fillRect(x,y,w,h);

      const capH = 25;
      const capW = w + 10;
      const capY = isBottom ? y : y + h - capH;

      this.cx.fillStyle = type.color;
      this.cx.fillRect(x-5, capY, capW, capH);

      this.cx.strokeStyle = "rgba(255,255,255,0.3)";
      this.cx.lineWidth = 2;
      this.cx.strokeRect(x,y,w,h);
      this.cx.strokeRect(x-5, capY, capW, capH);

      this.cx.fillStyle = "white";
      this.cx.textAlign = "center";
      this.cx.font = "bold 10px Arial";
      this.cx.fillText(type.name, x+w/2, capY+16);

      this.cx.font = "16px Arial";
      const iconY = isBottom ? y + 40 : y + h - 40;
      this.cx.fillText(type.icon, x+w/2, iconY);

      this.cx.font = "8px Arial";
      this.cx.fillStyle = "rgba(255,255,255,0.7)";
      const tagY = isBottom ? y + 55 : y + h - 25;
      this.cx.fillText(type.tag, x+w/2, tagY);
    }

    draw(){
      this.drawBackground();
      this.drawParticles();

      // collectibles (tux)
      for (const t of this.tuxes){
        this.drawTuxCollectible(t.x, t.y, t.size, t.rot);
      }

      // obstacles
      for (const o of this.obstacles){
        this.drawObstacle(o);
      }

      // player (windows logo)
      this.drawWindowsPlayer();
    }

    loop(){
      if(!this.running) return;
      this.update();
      this.draw();
      requestAnimationFrame(() => this.loop());
    }
  }

  window.addEventListener("load", () => new Game());
})();
</script>
</body>
</html>
